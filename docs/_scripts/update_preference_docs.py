"""Generate napari preferences documentation and screenshots.

This module provides functionality to automatically generate documentation for napari's
preferences/settings system. It creates both the textual documentation and screenshots
of the preferences dialog UI, ensuring that documentation stays synchronized with the
actual implementation.

Generated Content
-----------------
- Markdown documentation file at `docs/guides/preferences.md`
- Screenshots of each preferences section in `docs/images/_autogenerated/preferences-*.png`
- Screenshot of the reset dialog in `docs/images/_autogenerated/preferences-reset.png`

The documentation includes:
- Overview of napari's settings system
- Instructions for programmatic access
- Instructions for resetting settings via CLI
- Screenshots of each preferences section
- Detailed field documentation for each setting

Usage
-----
From command line:
    # Generate full documentation with screenshots
    python update_preference_docs.py

    # Generate only stub documentation (for quick builds)
    python update_preference_docs.py --stubs

From another script:
    from update_preference_docs import main
    main(stubs=False)  # Generate full documentation

Key Functions
-------------
generate_images()
    Captures screenshots of the preferences dialog for each section.

create_preferences_docs()
    Generates the markdown documentation using a Jinja2 template.

main(stubs=False)
    Main entry point that coordinates the documentation generation.

Notes
-----
- Screenshots are captured using Qt's grab() method
- The preferences dialog is styled with the dark theme for consistency
- Documentation is generated from the NapariSettings model fields
- Settings marked with `preferences_exclude` are documented but noted as not
  available in the UI

Attribution
-----------
This docstring was drafted with the assistance of Claude Code.
The output was reviewed and edited for accuracy and clarity.
"""

from pathlib import Path

from jinja2 import Template
from napari._pydantic_compat import ModelMetaclass
from qtpy.QtCore import QTimer
from qtpy.QtWidgets import QMessageBox

from napari._qt.dialogs.preferences_dialog import PreferencesDialog
from napari._qt.qt_event_loop import get_qapp
from napari._qt.qt_resources import get_stylesheet
from napari.settings import NapariSettings

DOCS = REPO_ROOT_PATH = Path(__file__).resolve().parent.parent
GUIDES_PATH = DOCS / "guides"
IMAGES_PATH = DOCS / "images" / "_autogenerated"
IMAGES_PATH.mkdir(parents=True, exist_ok=True)
PREFERENCES_TEMPLATE = """(napari-preferences)=

# Preferences

## napari settings

napari provides persistent settings that are stored on a *per environment basis*.
This means that if you have multiple Python environments, each with a napari installation (e.g.
different versions), the napari in each environment will have its own set of stored preferences.
So, for example, you could have an environment where napari always uses the Light theme and another one
where napari always uses the Dark theme.

A wide range of settings are available, organized into sections, and described in more detail below.

### Where settings are stored

Settings are stored in a `settings.yaml` file and napari uses [`appdirs`](https://github.com/ActiveState/appdirs)
to determine the save location: the platform-specific user configuration directory.
You can check where a napari installation has stored settings by looking for "Settings path" in the output of:

```bash
napari --info
```

## Resetting settings to defaults using the command line (CLI)

Sometimes, for example due to a version change, an issue with the stored settings can prevent
napari from launching or cause other issues. In those cases, it can be useful to reset the settings
to the defaults from the command line. To reset all napari settings to the default values:

```bash
napari --reset
```

## Programmatic access to the settings

Settings are managed by getting the global settings object and modifying settings:

```python
from napari.settings import get_settings

settings = get_settings()
# then modify... e.g:
settings.appearance.theme = 'dark'
```

You can get more information about individual settings, their types, and default values in each of the
settings section descriptions below.

## The Preferences dialog

napari provides a Preferences dialog to manage the settings using a graphical user interface (GUI).
Importantly, this dialog also allows you to customize napari keyboard shortcuts (keybindings).

On Windows and Linux, the Preferences dialog can be accessed in the **File** menu. On macOS, it can be
accessed in the **napari** menu.

The settings are grouped by sections that are accessible in a list on the left side of the dialog.

{% for section, section_data in sections.items() %}

## {{ section_data["title"] }} Settings

{{ section_data["description"] }}

![{{ section }}]({{ images_path }}/preferences-{{ section }}.png)

:::{dropdown} More details on the individual {{ section_data["title"] }} settings

{%   for fields in section_data["fields"] %}
{%     if fields["ui"] %}
##### {{ fields["title"] }}

*{{ fields["description"] }}*

* <small>Access programmatically with `SETTINGS.{{ section }}.{{ fields["field"] }}`.</small>
* <small>Environmental variable: `NAPARI_{{ section.upper() }}_{{ fields["field"].upper() }}`</small>
* <small>Type: `{{ fields["type"] }}`</small>

{% if section == "shortcuts" and fields["default"] is mapping -%}
**Default Shortcuts**

| Action | Shortcut |
|--------|----------|
{%- for key, value in fields["default"].items() %}
| {{ key }} | {{ value }} |
{%- endfor %}

{% else -%}
* <small>Default: `{{ fields["default"] }}`.</small>
{%- endif %}

{%     endif %}
{%   endfor %}

:::

{% endfor %}

## Reset settings to defaults using the Preferences dialog

To reset the preferences click on the `Restore defaults` button and continue
by clicking on `Restore Defaults`.

![{{ reset }}]({{ images_path }}/preferences-reset.png)

## Overriding settings

napari settings can also be overridden by using *environment variables*.
The variable names follow a pattern: they start with `NAPARI`,
followed by the Preference section name, yielding, for example, `NAPARI_APPLICATION`, followed by the setting
name, yielding, for example, `NAPARI_APPLICATION_CONFIRM_CLOSE_WINDOW`.
(This specific setting controls whether napari will prompt you to confirm closing the application.)
You can also find the environmentvariable names for each setting in the descriptions for each of the Preference sections above.

You can override settings for a single napari session by setting environment variables at launch:


On Mac and Linux:
```
NAPARI_APPLICATION_CONFIRM_CLOSE_WINDOW=False napari
```
On Windows:
```
set NAPARI_APPLICATION_CONFIRM_CLOSE_WINDOW=False && napari
```

Or programatically in a script/notebook:

```python
import os
os.environ['NAPARI_APPLICATION_CONFIRM_CLOSE_WINDOW'] = 'False'
```

Or, depending on your shell, you can persist environment variables for a shell session
using the `export` command (e.g. `bash`, `zsh`):

```bash
export NAPARI_APPLICATION_CONFIRM_CLOSE_WINDOW=False
```

 Or, to persist between shell sessions, add the above command to your
 shell configuration file e.g `~/.bashrc` or `~/.zshrc`.


"""


def generate_images():
    """
    Generate images from `CORE_SETTINGS`. and save them in the developer
    section of the docs.
    """

    app = get_qapp()
    pref = PreferencesDialog()
    pref.setStyleSheet(get_stylesheet("dark"))
    pref.show()
    QTimer.singleShot(1000, pref.close)

    # Collect all sections first
    sections = [field.field_info.title or name
                for name, field in NapariSettings.__fields__.items()
                if isinstance(field.type_, ModelMetaclass)]

    # Process each section with proper timing
    for idx, title in enumerate(sections):
        # Set current index
        pref._stack.setCurrentIndex(idx)
        pref._list.setCurrentRow(idx)

        # Process events to ensure UI has updated
        app.processEvents()

        # Capture screenshot
        pixmap = pref.grab()
        pixmap.save(str(IMAGES_PATH / f"preferences-{title.lower()}.png"))



    box = QMessageBox(
        QMessageBox.Icon.Question,
        "Restore Settings",
        "Are you sure you want to restore default settings?",
        QMessageBox.RestoreDefaults | QMessageBox.Cancel,
        pref,
    )
    box.show()

    def grab():
        pixmap = box.grab()
        pixmap.save(str(IMAGES_PATH / "preferences-reset.png"))
        box.reject()

    QTimer.singleShot(300, grab)
    app.exec_()


def create_preferences_docs():
    """Create preferences docs from SETTINGS using a jinja template."""
    sections = {}

    for name, field in NapariSettings.__fields__.items():

        if not isinstance(field.type_, ModelMetaclass):
            continue

        excluded = getattr(field.type_.NapariConfig, "preferences_exclude", [])
        title = field.field_info.title or name
        sections[title.lower()] = {
            "title": title,
            "description": field.field_info.description or '',
            "fields": [
                {
                    "field": n,
                    "title": f.field_info.title,
                    "description": f.field_info.description,
                    "default": f.get_default() if title.lower() == "shortcuts" else repr(f.get_default()),
                    "ui": n not in excluded,
                    "type": repr(f._type_display()).replace('.typing', ''),
                }
                for n, f in sorted(field.type_.__fields__.items())
                if n not in ('schema_version')
            ],
        }

    # pathlib strips trailing slashes, but because of the organization
    # of docs across napari/napari and napari/napari.github.io, we need
    # to build different paths for the images.
    # in napari/napari, they are located at
    #   docs/guides/images/_autogenerated
    # in napari/napari.github.io, they are located at
    #   guides/stable/images/_autogenerated
    text = Template(PREFERENCES_TEMPLATE).render(
        sections=sections, images_path="../images/_autogenerated"
    )
    (GUIDES_PATH / "preferences.md").write_text(text)


def main(stubs=False):
    if stubs:
        # Generate stubs file
        file_path = GUIDES_PATH / "preferences.md"
        if not file_path.exists():  # Avoid overwriting existing files
            file_path.write_text(
                "(napari-preferences)=\n# Preferences\nThis is a stub. The real file is autogenerated in a full build.",
                encoding="utf-8",
            )
    else:
        generate_images()
        create_preferences_docs()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Update preference docs.")
    parser.add_argument(
        "--stubs",
        action="store_true",
        help="Generate stubs versions of the preference docs.",
    )
    args = parser.parse_args()

    main(stubs=args.stubs)
